/*************************************************************************
                           BarriereEntree  -  Tache BarriereEntree
                             -------------------
    début                : 11/03/16
    copyright            : (C) 2016 par Toko Samuel
*************************************************************************/

//---------- Réalisation de la classe <BarriereEntree> (fichier BarriereEntree.cpp) --

//---------------------------------------------------------------- INCLUDE

//-------------------------------------------------------- Include système
using namespace std;
#include <iostream>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/wait.h>
#include <sys/sem.h>
#include <sys/shm.h>
//------------------------------------------------------ Include personnel
#include "BarriereEntree.h"
#include "Outils.h"

//---------------------------------------------------- Variables de classe
static int id_bal;
static int id_semReq;
static int id_semSync;
static int id_semCompt;
static int id_semPark;
static int id_mpReq;
static int id_mpParking;
static int id_mpCompteur;
static int numMemoire;
static TypeBarriere barriere;
static messVoiture newCar ;
static Voiture * parking;
static Requete * voiturePresente;
static unsigned int * compteurPlace;
static pid_t noFils;
static VoitureEnMouvement * mouvement;

//operation p
struct sembuf semP = {0, -1,0};
//operation v
struct sembuf semV = {0, 1,0};

//------------------------------------------------------ Fonctions privées

static void ITFin(int noSig)
// Mode d'emploi : Détache les mémoires partagées, tue les voituriers en activité
//				   et termine la tache BarriereEntree
//
// Contrat : Mise du handler sur SIGUSR2
//
// Algorithme :
//
{
	//Envoi de SIGUSR2 aux Voituriers
	for(int i=0;i<NB_PLACES;i++)
	{
		if(mouvement[i].id!=0)
		{
			kill(mouvement[i].id,SIGUSR2);
			waitpid(mouvement[i].id, NULL, 0);
		}
	}
	
	//Detachement des memoires partagees
	shmdt(voiturePresente);
	shmdt(parking);
	shmdt(compteurPlace);
	delete[] mouvement;
	exit(0);
}//----- fin de ItFin

static void ITFinFils(int noSig)
// Mode d'emploi : Ajoute la voiture qui vient de se garer dans la memoire
//				   partagée Parking et met à jour l'affichage de l'état du 
//				   parking
//
// Contrat : Mise du handler sur SIGCHLD
//
// Algorithme :
//
{
	
	int position,place,id;
	
	//Recuperation du pid du Voiturier
	id = waitpid(0, &place, 0);
	place = WEXITSTATUS(place);
	
	//Recherche des infos de la voitures qui vient de se garer
	for(unsigned int i=0;i<NB_PLACES;i++)
	{
		if(mouvement[i].id == id)
		{
			//Mise à jour du champ
			AfficherPlace(place, mouvement[i].infoVoiture.type, mouvement[i].infoVoiture.num, mouvement[i].infoVoiture.hEntree);
			
			//Ecriture de la voiture dans la memoire partagée Parking
			while(semop(id_semPark, &semP,1 )==-1);
			parking[place-1] = mouvement[i].infoVoiture;
			while(semop(id_semPark, &semV,1 )==-1);
			
			mouvement[i].id = 0;		
			break;
		}
	}
}//----- fin de ItFinFils

static void init(TypeBarriere barr, unsigned int semMP, unsigned int semSync, unsigned int semCompteur, unsigned int semPark,  
					unsigned int boiteAL, unsigned int MPReq, unsigned int MPPark, unsigned int MPCompteur)
// Mode d'emploi : Initialise la tâche BarriereEntree
//
// Contrat :
//
// Algorithme :
//
{
	//masque les signaux SIGUSR1 et SIGUSR2
	struct sigaction masquage;
	masquage.sa_handler = SIG_IGN;
	sigemptyset (&masquage.sa_mask);
	masquage.sa_flags = 0;
	sigaction (SIGUSR1, &masquage, NULL);
	sigaction (SIGUSR2, &masquage, NULL);
	
	//mise en place du handler ITFin
	struct sigaction action;
	action.sa_handler = ITFin;
	sigemptyset (&action.sa_mask);
	action.sa_flags = 0;
	sigaction (SIGUSR2, &action, NULL);
	
	//mise en place du handler ITFinFils
	struct sigaction action2;
	action2.sa_handler = ITFinFils;
	sigemptyset (&action2.sa_mask);
	action2.sa_flags = 0;
	sigaction (SIGCHLD, &action2, NULL);
	
	//recuperation de la barriere
	barriere = barr;
	
	switch(barriere) {
		case PROF_BLAISE_PASCAL :
			numMemoire = 0;
			break;
			
		case AUTRE_BLAISE_PASCAL :
			numMemoire = 1;
			break;
		
		case ENTREE_GASTON_BERGER :
			numMemoire = 2;
			break;
	}
	
	//récupération de la boîte aux lettres
    id_bal = boiteAL;
    
    //récupération du sémaphore sur MP req
    id_semReq = semMP;
    
    //récupération du sémaphore de synchro
    id_semSync = semSync;
    
    //récupération du sémaphore de parking
    id_semPark = semPark;
    
    //récup sémaphore de compteur
    id_semCompt = semCompteur;
   
    //récupération mémoires partagées pour la requete
    id_mpReq = MPReq;
    voiturePresente = (Requete *) shmat(id_mpReq,NULL,0);
    
    //récupération mémoires partagées pour le parking
    id_mpParking = MPPark;
    parking = (Voiture *) shmat(id_mpParking,NULL,0);
    
    //récupération mémoires partagées pour le compteur
    id_mpCompteur = MPCompteur;
    compteurPlace = (unsigned int *) shmat(id_mpCompteur,NULL,0);
    
    //Initialisation du tableau mouvement
    mouvement = new VoitureEnMouvement[NB_PLACES];
    for(unsigned int i=0;i<NB_PLACES;i++)
    {
		mouvement[i].id=0;
	}
}//----- fin de init

//----------------------------------------------------------------- PUBLIC

//----------------------------------------------------- Méthodes publiques


void BarriereEntree(TypeBarriere barr, unsigned int semMP, unsigned int semSync, unsigned int semCompteur, unsigned int semPark,  
						unsigned int boiteAL, unsigned int MPReq, unsigned int MPPark, unsigned int MPCompteur)
// Algorithme :
//
{
	init(barr, semMP, semSync, semCompteur, semPark, boiteAL, MPReq, MPPark, MPCompteur);
	
	for(;;)
	{
		//Recuperation du message
		while(msgrcv(id_bal, &newCar, sizeof(newCar.mVoiture), 1, 0) == -1);
		
		int placeParking;
		
		//Récupération du nombre de place restante
		while(semop(id_semCompt, &semP,1 )==-1);
		placeParking = (*compteurPlace);
		while(semop(id_semCompt, &semV,1 )==-1);	
		Afficher(MESSAGE, *compteurPlace);
		
		if(placeParking>0)
		{}
		else
		{	
			//Affichage de la requête		
			AfficherRequete(barriere, newCar.mVoiture.type, time(NULL));
			
			//Dessine la voiture derrière la barrière
			DessinerVoitureBarriere(barriere, newCar.mVoiture.type);
			
			//Depot de la requête
			semop(id_semReq, &semP,1 );
			voiturePresente[numMemoire].type = newCar.mVoiture.type;
			voiturePresente[numMemoire].hRequete = time(NULL);
			voiturePresente[numMemoire].used = 0;
			semop(id_semReq, &semV,1 );
			
			// Attente de l'autorisation de garage
			semop(id_semSync, &semP,1 );
			
			
		}
		
		//Mise à jour du nombre de place libre dans le Parking
		semop(id_semCompt, &semP,1 );
		(*compteurPlace)--;
		semop(id_semCompt, &semV,1 );
		
		//Creation voiturier
		pid_t voiturier = GarerVoiture(barriere);
		
		newCar.mVoiture.hEntree = time(NULL);
		
		//Mise à jour du tableau mouvement
		for(unsigned int i=0;i<NB_PLACES;i++)
		{
			if(mouvement[i].id==0)
			{
				mouvement[i].id=voiturier;
				mouvement[i].infoVoiture=newCar.mVoiture;
				break;
			}
		}
		
		//Attente de TEMPO secondes
		sleep(TEMPO);
	}
}//----- fin de BarriereEntree

